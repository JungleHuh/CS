### Virtual Memory

- 가상 메모리는 물리 메모리 크기의 한계를 극복하기 위해 나온 기술
- 물리 메모리보다 큰 프로세스를 수행하기 위해 가상 메모리를 사용한다
- 예를 들어, 100MB 메모리 크기에서 200MB 크기의 프로세스를 수행할 수 있도록 하는 것

## 이것을 어떻게 굴현할 수 있을까?

- 필요한 부분만 메모리에 적재
- 프로세스를 실행할 때, 실행에 필요한 부분만 메모리에 올리면 됨
- 프로세스의 일부분은 페이지 단위일 수도 있고, 세그먼트 단위일 수도 있지만 현재 대부분은 페이지 단위를 사용
- 필요한(요구되어지는) 페이지만 메모리에 올리는 것을 Demanding Paging(요구 페이징)

## 방법

1. CPU가 page table에 가서 해당 page에 접근한다.
2. 이 때, Memory에 올라온 상태가 아니면(invaild), Interupt를 발생한다.
3. OS 내부의 ISR에서 이 인터럽트를 처리하러 Disk에서 page를 찾는다.
4. 찾은 Page를 Memory에 올려 Frame화 한다.
5. page table을 업데이트 한다.
6. CPU에게 다시 수행하라고 명령한다.

## Page Fault

- CPU가 접근하려는 페이지가 메모리에 없는 경우 = 페이지 테이블의 valid bit값이 0인 경우
- Pure Demanding Paging: 프로세스가 최초로 실행될 때는 어떤 페이지가 필요한지 알 수 없으므로, 아무 페이지도 올리지 않는다. 그러므로 프로그램을 실행하자마자 page fault가 발생
- 순수하게 필요한 페이지만 올리는 것 의미
- Pure Demanding Paging의 장점은 메모리를 최대한 효율적으로 사용할 수 있다. 하지만 시작부터 page fault가 발생하므로 속도면에서 느림 /n

- Prepaging: 프로그램을 실행할 때 필요할 것이라 판단되는 페이지를 미리 올리는 것
- Page fault가 발생할 확률이 적으므로 속도면에서 빠르지만, 단점으로 미리 올라간 페이지를 사용하지 않는다면 메모리가 낭비 /n

- Swapping: Swapping은 프로세스 단위로 이동하고 Demanding Paging은 페이지 단위로 이동하는 차이점

## 지역성의 원리

- page fault는 매우 적은 확률로 발생해야 효율적
- 지역성의 원리(Locality of reference)로 인해 페이지 부재 확률은 매우 낮음 /n

- 시간적 지역성: CPU는 어느 메모리 공간을 읽은 후, 시간이 지나도 그 공간을 다시 읽을 확률이 매우 높다는 것
- 대표적인 예로 반복문 /n

- 공간적 지역성: CPU가 메모리 공간을 읽을 때는 인접한 범위 내에서 읽는다는 의미
- 프로그램은 대부분 절차적인 순서로 구현되어 있어 순서대로 읽는 경우가 빈번 /n

- 효율적으로 사용하기 위해서는 페이지 부재일 때 소요되는 시간을 줄일 수 있는데, backing store로 HDD를 사용하기 보다는 더욱 빠르게 동작하는 SSD나 저가 DRAM과 같은 것을 사용하는 방법이 있음

## 페이지 교체

- Demanding Paging은 요구되어지는 페이지만 backing store에서 가져온다.
- 하지만 프로그램들이 계속 실행함에 따라 요구 페이지도 계속 늘어나고, 언젠가는 메모리가 가득 차게 될 것이다
- 다른 프로그램이 새로 실행되거나 실행중인 프로세스가 다른 페이지를 요구한다면 이미 메모리에 있는 페이지 중 하나를 다시 backing store에 보내고(page-out), 새로운 페이지를 메모리에 올려야한다.(page-in)
- backing store로 page-out이 된 페이지를 victim page

## Victim Page

- 메모리에 올라가 있는 페이지 중 CPU에 수정(modify)되지 않는 페이지를 고르는 것이 효율적으로 보인다
- 즉, 읽기만 수행하는 페이지를 고르는 것이 이상적
- 수정되지 않은 페이지는 page-out이 될 때 backing store에 쓰기(write) 연산을 할 필요가 없기 때문
- backing store는 읽는 시간도 느리지만, 거기에 더해 쓰기 작업까지 한다면 더욱 비효율적일 것 /n

- 그러면 해당 페이지가 수정되었는지 안되었는지를 판단할 수 있어야 하는데, 이를 위해 페이지 테이블에 modified bit(=dirty bit)를 추가하여 이를 검사
- 해당 페이지가 수정되었다면 이 비트를 1로 두고, 수정되지 않으면 0으로 둔다.
- 이를 이용해서 victim page는 최대한 수정되지 않은 페이지를 선택 /n

출처: https://wansook0316.github.io/cs/os/2020/04/06/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A0%95%EB%A6%AC-16-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC.html
