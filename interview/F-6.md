### Array, List

## 배열(Array)

- 배열은 정적(static)인 자료구조
- 배열을 만들기 위해서는 미리 그 크기를 정해놔야하기 때문
- 크기를 정해놓고 배열을 만들게 되면 딱 그 크기 만큼 연속된 메모리 주소를 할당
- 한번 크기를 정해 놓으면 크기 수정이 불가하고 배열 크기 이상의 데이터를 저장할 수 없다는 단점
- 데이터가 순차적으로 저장되기 때문에 데이터가 인덱스를 가지게 되면서 임의 접근(random access)이 가능하다는 장점 가짐

## 리스트(List)

- 연결리스트는 동적(dynamic)인 자료구조
- 연결리스트는 크기를 미리 정할 필요가 없기 때문
- 연결리스트에는 노드가 존재하는데, 그 노드에는 저장된 데이터 값과 다음 데이터가 있는 메모리 주소(단일 연결리스트의 경우)를 가지고 있음
- 서로 떨어져 있어도 선형구조로 데이터를 저장할 수 있다는 장점
- 크기의 제한이 걸리지 않는다는 점이 되고 이 때문에 데이터 추가, 삭제가 굉장히 자유로워짐
- 하지만 연결리스트는 배열처럼 연속적으로 메모리 주소를 할당받지 않기 때문에 임의 접근이 불가능
- 연결리스트가 데이터를 탐색하는 방식은 순차 접근(sequential access)

## 시간복잡도

1. 탐색

- 연결리스트: 순차 접근 O(n)
- 배열: 임의 접근 O(1)

2. 데이터 추가

- 연결리스트: 맨앞 O(1), 맨 앞 이후 O(n)
- 데이터를 추가하는 행위 자체의 시간복잡도는 O(1)이다.
- 노드가 가지고 있는 메모리 주소 값만 갈아 끼워주면 되기 때문이다.
- 다만, 추가하려는 데이터의 위치가 맨 처음이 아니고 그 이후라면 순차적으로 탐색하면서 해당 위치까지 가야한다. 이 때 발생하는 시간복잡도가 O(n)이다.
  <br/>
- 배열
- 추가하려는 데이터가 맨 뒤가 아니라면, 추가되는 데이터 위치 이후에 있는 모든 데이터들을 한 칸씩 미뤄야 하므로 O(n)의 시간복잡도
- 추가하려는 데이터의 위치가 맨 뒤이고 배열에 공간이 남아있다면, O(1)의 시간복잡도

3. 데이터 삭제

- 연결리스트
- 삭제하려는 데이터의 위치가 맨 앞이라면, O(1)의 시간복잡도를 가진다.
- 삭제하려는 데이터의 위치가 맨 앞 그 이후라면, O(n)의 시간복잡도를 가진다
  <br/>
- 배열
- 삭제하려는 데이터의 위치가 맨 뒤가 아니라면, O(n)의 시간복잡도
- 삭제하려는 데이터의 위치가 맨 뒤이고 배열에 공간이 남아있다면, O(1)의 시간복잡도
