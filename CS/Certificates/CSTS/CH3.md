### 소프트에어 개발 단계와 테스트

# 컴포넌트 테스트
- 개별적인 모듈에 대해 컴포넌트 테스트를 진행하기 위해서는 모듈을 단독으로 실행할 수 있는 환경 필요
- 테스트 환경은 테스트 베드라고 함
- 테스트 환경의 주요 구성 요소로 테스트 드라이버와 테스트 스텁이 있음

![image](https://github.com/user-attachments/assets/6a715fc6-4dc9-4397-a619-6876a45f224a)

- 컴포넌트 테스트는 시스템을 구성하는 컴포넌트를 독립적인 방식으로 테스트를 수행하는 것이 특징
- 컴포넌트 0을 테스트할 때 컴포넌트 1과 2에 의존하지 않는 방식으로 수행
- 컴포넌트 1을 대상으로 테스트할 때 컴포넌트 2 대신 스텁 이용
- 갭려적인 컴포넌트의 독립적인 동작을 확인

# 모의객체 생성 프레임워크
- 독립적인 컴포넌트 테스트를 위해 절차 지향적 프로그래밍에서 스텁과 같은 개념이 필요
- 모의(Mock)객체는 스텁의 객체 지향 버전이라고 할 수 있음
- 모의 객체는 개발자가 처음부터 수작업으로 만들거나 모의 객체 생성 프레임워크를 이용하여 만들 수 있음

# 모의객체
- 더미 객체: 테스트할 때 객체만 필요하고, 해당 객체의 기능까지는 필요하지 않은 경우 사용
- 테스트 스텁: 더미 객체에 단순한 기능성을 작성하여 추가 객체의 특성 상태를 가정해서 특정 값, 메세지를 반환
- 테스트 스파이: 주로 테스트 대상 클래스(CUT)와 협력하는 클래스로 가는 출력을 검증하는데 사용됨, CUT이 실행되는 동안 특정 협력 클래스로의 호출이나 결과를 잡아내 실행 끝난 후 정상호출인지 검사
- 가짜 객체: ...

- ### First 원칙
- - 컴포넌트 테스트는 다른 테스트에 비해 테스트 수행에 대한 피드백이 빠름
  - 결함 발견시 결함을 발생시킨 부분을 쉽게 식별하게 수정할 수 있음
  - FIRST 원칙은 컴포넌트 테스트를 잘 수행하기 위한 것임
  - FAST: 컴포넌트 테스트의 주요 목정 중 하나는 리그레션 테스트
  - 코드를 변경할 때마다 4분이 넘는 테스트가 수행되면 개발자는 테스트를 건너뛰고자 하는 유혹에 빠질 수 있음
  - 또한 코드에 새로운 기능,DB가 추가될수록 테스트 시간은 증대됨
  - 모의객체 생성 프레임워크를 이용하여 테스트 시간을 단축하는게 좋음
    
  - ISOLATED: 어떤 특정한 컴포넌트 테스트 집합이나 컴포넌트 테스트 하나를 독립적으로 수행할 수 있어야 함
  - 컴포넌트 테스트가 다른 컴포넌트 테스트 결과에 의존하면 테스트 실행 순서에 따라 다른 결과가 나올 수 있음
  - 전체 컴포넌트 테스트 집합을 실행한 결과와 개별적 컴포넌트 테스트 결과가 다르면 안됨
    
  - REPEATABLE: 반복해도 계속 똑같은 결과가 나와야함
  - 개발자 자신ㅋ만이 사용할 수 있는 샌드박스를 구축해서 테스트를 수행하는 것이 좋음
  
  - SELF-VALIDATING: 사람의 개입없이 테스트가 통과되었는지 알 수 있도록 작성해야함
  - 사람이 개입하도록 하면 많은 시간이 소요되기 떄문에, 사람이 개입되지 않는 것이 좋음
    
  - TIMELY: 제 때 수행되어야함. 테스트 대상이 되는 코드가 작성되는 시점을 의미
  - TDD에서는 코드 작성 바로 전을 가리킴
 
  ### 통합 테스트
  - 통합 테스트는 컴포넌트를 통합하는 과정에서 수행되는 테스트
  - 컴포넌트 간 상호연동이 제대로 수행되었는지 검사
  - 개별적인 컴포넌트에 대해 테스트가 수행되었더라도 실제 컴포넌트 통합 후 결함이 생길 수 있음
 
  # 통합 테스트 목적에 따른 두가지 관점
  - 자료에 따라 통합 테스트가 두 컴포넌트 간 연결의 정확성에만 초점을 두는 경우
  - 연결된 두 컴포넌트의 기능적인 측면에 초점을 두는 경우

  # 상호작용에만 초점을 두는 통합 테스트
  - 두 컴포넌트 간에 전송, 수신된 데이터를 중심으로 봄
  - Output1에서 전송 데이터에 대한 로그를 생성, Input2에서 수신 데이터에 대한 로그를 생성하여 두 값을 비교
  - 시스템에 따라 전송, 수신 로그를 생성하는 것이 용이하지 않을 수 있음
  - 임베디드 소프트웨어는 로그를 기록하기 위한 메모리, 파일시스템의 공간이 제한적이기 때문에 크기 최소화
  - 데이터 전체를 로그로 남기는 대신 핑거 프린트를 사용하여 데이터 변경 여부만 확인
 
  # 기능에만 초점을 두는 통합 테스트
  - 컴포넌트 테스트를 수행할 때는 스텁을 사용했지만, 통합 테스트에서는 실제 컴포넌트를 사용
  - 컴포넌트 간 연결 자체에서 오작동이 발생할 가능성이 높다면 상호작용에만 초점을 두고 테스트
  - 컴포넌트 간 통신 문제가 있을 가능성이 작다면 기능 위주 통합 테스트 진행
 
  # 점진적 통합
  - 통합 대상 컴포넌트가 많아서 한 번에 통합하여 테스트하는 방법을 빅뱅 방식이라고 함
  - 한 번에 통합하는 경우, 이 중에서 결함을 가진 컴포넌트를 찾는 것이 어려움
  - 이 때 빅뱅 방식 대신 점진적 방식을 사용하는 것이 효과적
  - 점진적 방식은 오작동의 원인이 되는 컴포넌트를 찾기 쉽지만 테스트 드라이버, 스텁을 여러번 개발해야 함

  ![image](https://github.com/user-attachments/assets/0a41cb93-2f7a-4642-92d5-bb888126466f)

# 상향식 통합
- 하위 컴포넌트를 식별하여 그룹화, 클러스터링 한 후에 테스트 드라이버를 작성하여 테스트 수행
- 여러 모듈의 묶음을 클러스터 또는 빌드라고 함
- 클러스터를 테스트 한 후 드라이버를 제거하고 실제 모듈과 결합
- 이 과정을 시스템이 완전히 통합될 때까지 반복
- 하위 컴포넌트를 충분하게 테스트할 수 있음
- 하위 컴포넌트는 시스템이 제공하는 서비스에 필요한 공통적인 기능을 제공하는 역할을 함
- 컴포넌트가 하위에 있을수록 여러 상위 컴포넌트가 빈번하게 사용되는 코드를 갖는다고 간주(?)
- 하양한 통합에서 필요한 스텁을 제공하는 비용이 들지 않음

# 하향식 통합
- 가장 상위에 있는 컴포넌트 테스트를 위해 하위 컴포넌트를 테스트 스텁으로 대치하고 테스트를 수행
- BFS/DFS를 사용하여 테스트 스텁을 한 번에 하나씩 실제 컴포넌트로 대치하고, 대치된 컴포넌트가 실제로 호출하는 하위 컴포넌트를 테스트 스텁으로 대치
- 테스트 스텁이 실제 모듈로 대치되어 시스템에 변경이 발새해서 리그레션 테스트를 수행
- 컴포넌트 종속 관계에서 기본적으로 상위는 시스템 기능을 결정, 하위는 시스템이 제공하는 기능으 ㄹ보조
- 하향식 통합 테스트 방법에서는 많은 수의 테스트 스텁이 필요

![image](https://github.com/user-attachments/assets/84a51dd4-74ef-4128-a889-aa7b7664af14)

# 샌드위치 통합
- 상위 컴포넌트 M1은 M2, M3, M4에 해당하는 테스트 스텁을 사용하여 테스트하고, M5,M6,M7은 클러스터링하여 테스트 드라이버 D1을 사용하여 테스트
- 클러스터에 대한 테스트가 완료되면 실제 컴포넌트 M2를 통합하고, 나머지 컴포넌트 M3,M4도 추가 통합하여 완전한 시스템 구축

### 시스템 테스트 및 인수 테스트

# 시스템 테스트
- 통합 테스트 완료 후 전체 시스템이 시스템 명세에 따라 개발되었는지 검증
- 기능 측면 뿐만 아니라 성능, 호환성, 사용성, 신뢰성, 보안성, 유지보수성, 이식성 등과 같은 비기능적인 요구사항을 만족하는지도 검증
- 시스템 테스트가 완료되면 인수 테스트 진행

# 인수 테스트
- 주목적인 결함 검출이 아니라 시스템을 인수해도 되는지 고객의 입장에서 평가
- 테스트 케이스는 사용자 또는 소프트웨어 구입자가 제시할 수도 있고, 시스템 테스트에서 사용했던 테케를 사용할 수 있음
- 알파 테스트: 선택된 사용자가 개발자 환경에서 통제된 상태로 수행
- 베타 테스트: 일정 수의 사용자에게 소프트웨어를 사용하게 하고 피드백을 받음(개발자는 참여하지 않음)

# 리그레션 테스트
- 유지보수 단계에서도 소프트웨어가 수정된 후 변경이 올바르게 되었는지 검사하기위해 리그레션 테스트 수행

# 유지보수 단계에서의 소프트웨어 수정

- 결함 수정 작업: 소프트웨어를 사용하는 중에 발견된 결함을 수정하기 위해 소프트웨어를 변경하는 유지보수 활동
- 기능 보강 작업: 소프트웨어 기능을 추가하거나 성능을 개선하기 위해 소프트웨어를 변경
- 적응 작업: 새로운 운영체제 환경에 적응시키기 위함
- 예방 작업: 더 나은 유지 보수를 위해 기존 소프트웨어 시스템에 대한 문서 준비, 시스템 구조를 유지보수하기 용이한 새로운 구조로 변경하는 작업

![image](https://github.com/user-attachments/assets/73bd6729-c914-4a7e-8cf4-76fdf29a7062)

- 유지보수 활동에는 필연적으로 소프트웨어 수정 작업이 수반됨
- 소프트웨어가 변경되었을 때 변경 작업으로 인해 새로운 결함이 발생하지 않았나 확인해야 함.

![image](https://github.com/user-attachments/assets/b7d14bd4-0344-47b8-aaab-78a2ae94298f)

- 리그레션 테스트에서는 테스크 케이스의 규모를 중요하게 고려해야 함
- 시간이 갈수록 새로운 기능이 추가되는 시스템이라면 리그레션 테스트에 소요되는 비용과 시간도 늘어남

### 리그레션 테스트 종류
- Rest All: 기존에 개발된 모든 테스트 케이스를 사용하는 방식
- 복잡한 테스트 절차를 요구하지는 않지만 너무 많은 시간과 자원을 필요로함
- 선택적 리그레션 테스트: 기존 테스트 케이스 중 일부만 선정하는 방식
- 슬라이싱 기법, 자료 흐름 분석 기법 같은 변경 영향 분석을 통해 다른 결과를 출력하는 테스트 케이스 식별
- 테스트 최소화: 중복된 테케 제거해서 테케 수 줄이는 방식, 커버리지 방식 사용
- 영향을 받는 부분을 테스트할 테커가 제거될 위험이 있음
- 테스트 우선 순위화: 테케에 우선순위를 두고, 우선 순위 높은 테케만 사용
- APFD가 많이 사용됨.

 ### APFD
 - 테케 실행 순서에 따라 APFD가 큰 차이를 보임
 - APFD가 높다 -> 더 적은 수의 테케 실행해서 많은 결함을 빠르게 검출 가능함을 의미
 - 결함 검출률이 높은 테케 식별은 현실적으로 어려움
 - 비즈니스 중요도, 리스크, 테케 실행시간, 커버리지, 결함 검출 내역 등 요인을 고려하여 우선순위 결정
- ![image](https://github.com/user-attachments/assets/b9a0594e-6284-4947-9c05-4de4a9fe3fa8)

### 리그레션 테스트 추가적인 개념
![image](https://github.com/user-attachments/assets/7b21d033-d26a-4395-b205-8ebdf7969368)
- 리그레션 테스트는 컴포넌트, 통합, 시스템 등 모든 단계에서 실행됨
- 테스트 유지보수 단게에서는 더 이상 필요없는 테케 제거하는 과정이 있음
- 비즈니스에 필요하지 않아 어플리케이션에서 제거되면, 이를 테스트하는 테케도 제거되야 함
- 요구사항이 변경되어 입출력 관계가 변할 수 있음
- 해당 테케를 요구사항 변경에 따라 변경하는 작업이 필요
- 새로 추가된 테케가 있으면, 이 테케를 자동화하는 편이 효율적
- 새로 추가된 테케를 자동화하는 작업도 중요한 테스트 유지보수 작업에 해당

# 테스트 드라이버, 스텁

### 드라이버: 데스트 대상 모듈을 호출하는 더미 프로그램

### 스텁: 테스트 대상 모듈에 의해 호출되는 프로그램
