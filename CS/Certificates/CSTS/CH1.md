# 테스트 목적
1. 결함의 검출과 제품 품질 개선
2. 품질 평가와 의사결정 지원
3. 개발 프로세스 개선 지원
4. 정해진 요구사항을 만족하는지 확인, 주어진 표준 준수하는지 검증하기 위해 수행

# 오류, 결함, 장애

### 오류
- 사람에 의해 발생되는 실수
- 요구사항 제대로 파악하지 못한 실수(요구사항 불이행)
- 결함을 유발시키는 개발자의 행위

### 결함 
- 잘못된 로직으로 인해 발생한 에러
- 소프트웨어 내에 장애를 유발할 수 있는 문제(부정확한 구현, 필요 기능 미포함)
- 누락, 비관련, 부정한 구현으로 분류

### 장애
  - 요구사항과 다르게 동작
  - 소프트웨어를 구성하는 요소에 부족한 점이 있어서 발생
 
# 결함의 유형
![image](https://github.com/user-attachments/assets/ddb29896-5f4d-42b3-969d-fbb912a602f9)

### 누락
- 요구사항이 시스템 구현에 반영되지 않은 결함
- 성능, 보안, 안전, 신뢰도 등 품질 요소에 관련한 누락

### 부정확한 구현
- 요구사항이 소프트웨어에 부정확하게 반영된 결함

### 비관련
- 요구 명세와 관련되지 않은 구현
- 직접적인 장애를 유발하지는 않지만 불필요한 분석, 테스트, 관리의 노력을 유발

# 개발 단계별 결함
![image](https://github.com/user-attachments/assets/e5cfa61d-76db-4544-a642-c89e7c5b1438)
* 결함을 검출하여 제거하지 않으면 다음 단게에 영향을 끼쳐 장애를 유발함
* 결함을 제거하지 않고 개발 단게로 나아가면 제거를 위해 더 많은 비용이 소모됨

![image](https://github.com/user-attachments/assets/b0e34216-85ee-4eb5-b9b6-0393396888f3)

# 테스트, 디버깅, 재테스팅
![image](https://github.com/user-attachments/assets/f8c764bc-675a-4e4b-b0d8-04f7358e39db)

### 테스팅
- 실제 동작과 요구사항의 차이를 확인
- 동적 테스트: 결함의 존재 여부를 모르고 발견을 목적으로 프로그램 실행
- 장애가 있을 때 결함이 존재한다고 추측
- 테스팅 결과는 결함을 검출한 테스트 케이스와 테스트 환경으로 구성됨
- 어떤 모듈에서 발생했고, 해결하기 위해 소스 코드를 어떻게 수정해야하는지에는 관여하지 않음

### 디버깅
- 결함의 존재를 확인한 후에 결함의 위치를 파악하고, 제거를 목적으로 진행
- 결함 제거를 위해 소스코드 수정

### 재테스팅
- 실제로 결함이 제거되었는지 확인

# 테스트의 현실/실제

### 완벽한 테스트의 비현실성
- 다익스트라: 프로그램 테스트는 결함이 있음을 보일 수 있지만, 결함이 없음을 보일 수는 없다.
- 동적테스트: 테스트의 한계를 고려해서 테스트 케이스를 설계, 동등 분할, 경곗값 분석, 조합 테스트 등
- 위험 기반 테스트 방법: 위험 분석을 바탕으로 테스트할 범위 선정

# 테스트의 진화과정

### 갤퍼린과 헤첼 5레벨
-레벨1: 테스트, 디버깅에 차이가 없음/ 우연히 발견된 결함을 수정하는 디버깅에 중점
-레벨2: 시스템의 정상 작동을 증명하는데 초점이 맞추어진 테스트 케이스를 설계하는 경향이 있음
-레벨3: 결함이 존재함을 보여주기 위한 테스트, 의도적으로 테스트 케이스 설계, 결함을 발견한 테스트 케이스가 그렇지 못한 테스트 케이스보다 가치 있음
-레벨4: 소프트웨어 개발 전 단계에서 발생하는 결함을 발견하는 개념으로 확장, 개발 초기 단계부터 지속적 리뷰
-레벨5: 결함 발생을 사전에 방지, 테스트 케이스르 미리 설계, 테스트 주도 개발(TDD)

### 테스트 원칙: 마이어스 원칙
- 테스트는 반드시 프로그램을 개발한 그룹과 무관한 그룹이 수행
- 결함이 발견되지 않으리라는 가정 하에 테스트 계획을 수립하면 안됨(갤퍼린과 헤첼 레벨3)
- 타당한 경우 뿐만 아니라, 타당하지 않고 예상하지 못한 경우도 테스트 수행(정수형에 문자열 입력하는 등..)
- 프로그램의 어떤 부분에 결함이 남아있을 확률은 그 부분에서 이미 발견된 결함 수에 비례(파레토 법칙)
- 결함이 많이 발생한 곳에 집중하는 것이 좋음(파레토 법칙)
- 테스트 케이스를 체계적으로 관리(수정 후에도 원래 테스트케이스 확인)
- 각각의 테스트 결과를 철저하게 점검

# 테스트와 품질

### 테스트와 품질 평가
- 기능 적합성: 요구되는 기능을 만족시키는 능력
- 성능 효율성: 적절한 자원의 사용 및 적정한 반응시간 정도
- 호환성: 다른 시스템과의 상호 연동 능력
- 사용성: 사용자가 이해하고 배우기 쉬운 정도
- 신뢰성: 규정된 조건에서 규정된 기간 동안 오동작 없이 의도된 기능을 수행하는 소프트웨어의 능력
- 보안성: 정보 및 데이터를 보호하는 능력
- 유지보수성
- 이식성

- 기능테스트: 기능 요구사항에 중점을 둔 테스트
- 비기능테스트: 품질 요구사항에 초점을 둔 테스트
- 유형테스트: 각 품질 특성 별로 수해외는 테스트(성능 테스트 ,보안 테스트 신뢰성 테스트)

# 테스트와 품질 보증
  ![image](https://github.com/user-attachments/assets/b1abfe30-61b7-4ec3-a632-966e48fdf73e)

  ### V&V(Verification and Validation)
  - 검증은 개발 과정에서 수행한 활동의 적합성 검사에 초점
  - 결과물에 적절하게 반영되었는지 조사하는 추적성 확인이 필요함
  - 확인은 결과물의 적합성에 초점, 소프트웨어가 주어진 요구사항을 충족하는지롹인
  - 요구사항 평가, 인터페이스 분석, 추적성 분석, 심각성 분석
 
  ### V&V는 정형 방법, 테스팅, V&V 분석으로 분류됨
  - 정형 방법: 모델 체킹, 정확성 증명
  - 테스팅: 동적 테스팅과 정적 테스팅
  - V&V 분석: 시뮬레이션, 평가
 
  ### 품질 보증
  - 프로그램 요구사항과 시스템 요구사항이 이해관계자 요구사항과 부합하는지 테스트
  - 소프트웨어 요구사항이 시스템 요구사항에 부합하는지
  - 프로세스와 표준 및 절차가 프로세스 요구 사항에 부합하는지
  - 프로세스 활동의 수행이 프로세스, 표준 및 절차에 부합하는지
  - 소프트웨어가 소프트웨어 요구사항에 부합하는지
 
  # 테스트 용어

  ### 테스트 대상
  - 결함을 검출하려는 대상 소프트웨어
  - 규모가 클수록 전체 테스팅이 어려움, 부분 테스트 후에 전체 테스트를 수행하는 것이 효과적
  - 시스템 테스트: 전체 소프트웨어 대상
  - 단위/컴포넌트 테스트: 부분 대상
  - 통합 테스트: 각 부분의 연결에 초점을 맞춘 테스트
 
  ### 피처
  - 테스트하고자 하는 관점
  - 다양한 측면에서의 소프트웨어에 대한 기대
  - 요구는 요구 분석 단계를 거쳐서 요구사항 명세서에 기록
  - 테스트 계획을 수립할 때 식별되어 테스트 범위로 기술되고 테스트 설계 활동을 통해 피처가 구체화됨
 
# 테스트 설계 기법

### 정적 테스트(리뷰, 정적 분석)
- 대상을 실행하지 않고 테스트를 수행하는 방법
- 해당 단계의 산출물이 품질 목표에 부합하는지 점검하거나 산출물에 존재하는 결함을 검출하려는 목적
- 소스 코드에 결함으로 판단할 수 있는 특정한 패턴이 있는지 분석
- 실행 환경을 필요로 하지 않음
- 소스 코드 작성 전 요구분석 단계, 구조 설계 단계, 상세 걸계 단계 등에서 수행
- 자동화 도구 사용: 테스트 자동으로 수행 가능/ 결함이 아닌 문제를 결함으로 보고하는 오검지 발생 가능

## 리뷰
- 리뷰 절차: 경영진 준비 -> 리뷰 계획 -> 리뷰 절차 개요 설명 -> 작업물 개요 설명 -> 개별 준비 -> 그룹 검토 -> 재작업 -> 후속 작업
- 목적 및 구체적인 수행방법에 따라 관리 리뷰, 기술 리뷰, 인스펙션, 워크쓰루, 감사로 구분
- 관리 리뷰: 프로젝트 진행 상황에 대한 검토를 바탕으로 일정, 인력, 범위 등에 대한 통제 및 의사결정 지원
- 기술 리뷰: 정의된 계획 및 명세를 준수하고 있는지에 대한 검토를 수행
- 인스펙션: 문제를 식별하고 문제에 대한 올바른 해결을 검증
- 워크쓰루: 문제를 식별하고 더 나아가서 대안조사, 개선 활동, 학습 기회 제공 등 수행
- 감사: 객관적인 표준과 규제에 대한 준수를 독립적으로 평가

## 정적 분석
- 산출물의 구조적 속성을 이용하여 자동화된 방식으로 도구에 의해 수행
- 코딩 표준: MISRA-C, MISRA-C++표준에 대한 준수 여부 검사
- 복잡도 측정: 사이클로매틱 복잡도 등으로 프로그램 복잡도 측정
- 자료흐름 분석: 프로그램 자료 흐름에 이상 존재 여부 파악


### 동적 테스트
- 소프트웨어를 실행하는 방식으로 테스트 수행
- 적절한 입력값(테스트 케이스)를 결정해야 함
- 소프트웨어의 어떤 부분에 결함이 존재하는지 알 수 없음으로 가능한 많은 경우의 수를 조사
- 결함을 누락하지 않으면서도 테스트 비용을 절감하려면 가능한 적은 수의 테스트 케이스를 사용하도록 설계
- 명세 기반 방법: 내부 논리 구조(소스 코드)를 참조하지 않고 요구 명세나 설계 정보를 이용하여 테스트케이스를 개발, 시스템의 명세 정보를 얻을 수 잇는 한 대상에 제한이 없음 컴포넌트 테스트, 통합 테스트, 시스템 테스트 및 인수 테스트 등 전과정에 걸쳐 사용 가능
- 명세 기반 방법: 동등 분할, 분류 트리 기법, 경곗값 분석, 신텍스 테스트, 조합 테스트, 상태 전이 템스트, 인과 그래핑, 결정표 테스트, 시나리오 테스트
- 구조 기반 방법: 프로그램의 제어 흐름이나 자료 흐름 정보(소스 코드)를 이용해서 테스트 케이스를 설계하는 방법, 내부 구조 정보로 테스트 케이스를 설계. 구조적 테스트, 화이트박스 테스트, 글래스 박스 테스트라고 함
- 구조 기반 방법: 문장 테스트, 결젱 테스트, 조건 테스트, 결정/조건 테스트, 다중 조건 테스트, 변형 조건/결정 테스트, 기본 경로 테스트
- 경험 기반 테스트: 테스트 케이스 설계를 바탕으로 테스트를 수행하지 않고 도메인에 대한 테스터의 경험, 기존 테스트 결과, 테스터의 직관을 주로 활용하여 테스트를 수행. 오류 추정, 탐색적 테스트
- 실행 가능한 소프트웨어가 필요
- 소스 코드는 사용되지 않음
- 소프트웨어 실행 환경 요구

### 오류 추정
- 개발자가 범할 수 있는 실수를 추정하고 이에 따라 결하밍 검출될 수 있도록 테스트 케이스 설계
- 기본 아이디어는 발생할 수 있는 오류 상황을 나열하는 것에서 시작
- 동등 분할이나 경곗값 분석 같은 명세 기반 테스트 방법과 함께 사용될 수 있음
- 동등 분할 방법에서 유효한 분할은 테스트 대상에 대한 명세를 통해 식별되지만 유효하지 않은 값의 영역은 명세의 정의가 명확하지 않아서 테스터의 경험과 직관을 활용하여 결정해야 함
- 오류가 검출된 대표적인 사례를 이용하는 것이 가장 효과적

- 필수 입력: 필수 입력 항목인 경우에, 값이 입력되지 않은 상황을 테스트
- 입력 항목의 길이: 입력 항목의 길이에 제약이 있는 경우, 더 작거나 긴 항목이 입력되는 상황을 테스트 ex) 주민등록 번호 앞자리는 여섯자리여야 함
- 입력 항목의 형식: 입력 항목 형식 위반하는지 테스트 ex) 생년월일 형식
- 입력 값의 명시적 제약 사항: 입력 항목 값에 대해 명시적으로 정해진 범위를 위반하는 상황을 테스트 ex) 월: 01~12 / 일 01 ~ 31
- 입력값의 묵시적 제약 사항: 입력 항목의 값에 대해 명시되지 않았지만, 상식적으로 가정되는 범위를 위반하는 상황을 테스트 ex) 올해가 21년일 때 19년을 입력

### 탐색적 테스트
- 테스트 대상에 대한 이해, 테스트 케이스 설계, 테스트 실행을 병행하는 방식
- 테스트 대상에 대한 이해를 바탕으로 즉석에서 테스트 케이스를 결정하고 문서화 없이 해당 테스트를 바로 수행
- 테스트를 위한 문서를 작성하지 않음, 테스트에 사용하는 자동화 도구로 테스트 로그, 결과 등을 자동으로 생성
- 에자일 방법을 사용하는 웹 으용 시스템의 테스트에 적합
- 명확한 가이드가 없으면 과도한 시간 사용/ 중복 테스트/ 테스트 적합성(커버리지) 문제 발생

# 테스트 절차
- 준비된 테스트 케이스의 입력값을 실제 테스트 대상에 입력해서 테스트 대상물을 실행
- 준비, 실행, 결과 관찰, 기록
- 테스트 절차는 검출된 결함을 재연할 때도 사용
- 문서로 기록하는 대신 자동화도구가 해석하고 실행하는 언어로 작성한 것을 테스트 스크립트라고 함

### 테스트 환경
- 컴포넌트, 단위 테스트의 경우 대상이 일부분(컴포넌트 또는 모듈)
- 컴포넌트 자체가 독립적으로 실행될 수 없음 -> 드라이버와 스텁 사용
- 테스트 실행 시 사용될 수 있는 다양한 테스트 도구도 테스트 환경으로 간주
- 시스템이 동자하는 실제 환경과 최대한 유사한 환경에서 테스트 수행

# 테스팅 방법

### 리그레션 테스트

# 유지 보수 단계에서의 소프트웨어 변경
- 사용자가 사용 과정에서 발견한 결함이 보고될 경우 이를 제거하기 위해 수정
- 기능을 추가하거나 성능을 개선하기 위해 수정
- 새로운 운영 환경에 적응하기 위해 수정
- 더 높은 수준의 유지보수성을 확보하기 위해 수정
- 리그레션 테스트는 변경 후에 수행되는 테스트, 소프트웨어에 가해진 변경이 의도치 않게 결함을 만들지는 않았는지, 시스템이 기존의 요구사항을 충족하는지 등을 검증하기 위해 사용됨
- Retest-all 전략, 선택적 리그레션 테스트 전략, 테스트 최소화 전략, 테스트 우선순위화 저략
- 각 레벨 테스트 순서대로(컴포넌트, 통합, 시스템) 리그레션 테스트 수행
  
출처: https://snnchallenge.tistory.com/354
목적: 공부하기 위해서 위 블로그의 내용을 똑같이 타이핑했습니다.

![image](https://github.com/user-attachments/assets/ffcaee2f-3741-460b-8aed-cde1d517b90d)

  


