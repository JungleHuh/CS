### 1. 리눅스와 유닉스의 차이점

(예시 답변)  
-- 
유닉스는 1970년대 AT&T 벨 연구소에서 개발된 상용 운영체제이고, 리눅스는 1991년 리누스 토르발스가 유닉스를 참고해 개발한 오픈소스 운영체제입니다.
유닉스는 주로 서버, 메인프레임 등 기업 환경에서 사용되며, 상용 라이선스가 적용됩니다.
반면, 리눅스는 GNU 프로젝트와 결합되어 무료로 사용 가능하고, 다양한 배포판을 통해 데스크탑, 서버, 임베디드 시스템 등 광범위하게 활용됩니다.
구조적으로는 둘 다 POSIX 표준을 따르기 때문에 기본적인 명령어와 시스템 콜 인터페이스는 유사하지만, 리눅스는 더 자유롭게 커스터마이징할 수 있다는 점에서 개발자와 연구자에게 특히 많이 사용됩니다.

### 2. 리눅스 커널이란 무엇인가요?

(예시답변) 
--
리눅스 커널은 리눅스 운영체제의 핵심으로, 하드웨어와 사용자 프로그램 사이를 중재하는 핵심 소프트웨어입니다. 주요 역할은 프로세스 스케쥴링, 메모리 관리, 파일 시스템, 네트워크, 디바이스 제어 등 시스템 자원의 효율적 관리입니다.
리눅스 커널은 모노리식 커널 구조로, 주요 기능이 하나의 커널 공간에서 실행되어 성능이 뛰어나고, 커널 모듈을 유연하게 확장할 수 있습니다. 
저는 커널 모듈을 직접 작성해보고, insmod와 dmesg로 커널 로그를 확인하며 디바이스와 상호작용했던 실습 경험을 통해, 커널이 실제로 하드웨어를 어떻게 제어하는지를 깊이 이해할 수 있었습니다.

(실습 예시 답변)
--
제가 진행한 리눅스 커널 실습에서는, GPIO 핀을 제어하는 커널 모듈을 직접 작성하고 이를 통해 하드웨어와의 인터페이스를 경험했습니다.
모듈을 insmod로 커널에 삽입하고, dmesg로 커널 로그를 확인해 디버깅하며, LED를 PWM 방식으로 제어하는 기능을 구현했습니다.
또한 ioctl을 사용해 사용자 공간에서 커널 모듈로 제어 명령을 전달해보며, 시스템 콜을 통한 상호작용 구조를 이해했습니다.
이 실습을 통해 커널 공간과 사용자 공간의 차이, 그리고 리눅스 커널이 하드웨어와 어떻게 연결되는지를 실무적으로 체감할 수 있었습니다.

(실습 예시 답변2)
--
제가 작성한 커널 모듈은 GPIO 제어 기능을 담고 있었고,
insmod로 모듈을 삽입한 뒤 dmesg 로그를 확인하면서 init 루틴이 잘 작동하는지 확인했습니다.
실습 중 오류가 발생했을 땐 printk()를 통해 커널 로그를 찍고, rmmod로 모듈을 제거하면서 반복적으로 디버깅했습니다.
이 과정을 통해 실제로 커널 공간에서 모듈이 어떻게 동작하고, 하드웨어와 연결되는지를 깊이 있게 이해할 수 있었습니다.


#### 커널 모듈을 작성한다는 것
- 커널 모듈(kernel module)은 리눅스 커널 기능을 동적으로 확장하는 코드 조각
- 보통 리눅스 커널은 부팅할 때 한 번에 메모리에 올라가지만, 모듈은 필요할 때만 커널에 "끼워넣고(insmod)", 뺄 수(rmmod)" 있는 플러그인 형태
- 기본 커널에는 없지만, 특정 하드웨어를 제어하고 싶을 때(예: LED, 모터),내가 만든 my_driver.ko 같은 모듈을 insmod 명령으로 커널에 추가해서 동작시킴
- 커널 모듈을 작성한다는 것은 하드웨어와 직접 연결되는 디바이스 드라이버를 C언어로 직접 작성하고, 이를 커널 공간에 삽입해서 동작시키는 것

#### PWM(Pulse Width Modulation)
- 디지털 신호를 아날로그처럼 보이게 하는 제어 방식(LED 밝기, 모터 속도 제어에 쓰임)
- 1초에 100번 ON/OFF한다고 했을 때, 70%동안 On이면 밝은 빛, 70%동안 OFF이면 어두운 빛
- On의 비율(듀티 싸이클)로 출력을 조정

#### Ioctl(Input Output Control)
- 사용자 공간에서 커널 공간으로 제어 명령 보낼 때 사용하는 시스템콜
- Read/Write는 단순히 데이터만 주고 받는데에 비해, Ioctl은 LED를 켜라, 밝기를 50으로 바꿔라와 같은 명령 전달
- ioctl(fd, LED_ON, 1); // 사용자 공간에서 커널 모듈에게 "LED 켜!"라고 명령

-- 
### 3. 리눅스는 어떤 방식으로 프로세스를 생성하나요?

(예시답변)
--
리눅스에서 프로세스는 보통 fork() 시스템 콜을 통해 생성됩니다.
fork()는 현재 프로세스를 복제하여 자식 프로세스를 만들고, 부모와 자식은 각각 독립적인 실행 흐름을 갖게 됩니다.
이후 자식 프로세스는 보통 exec() 계열 함수(execve, execl, execvp 등)를 호출해서,
새로운 프로그램을 메모리에 로드하고 실행합니다.
즉, 리눅스에서는 일반적으로 fork()로 프로세스를 복제하고 → exec()로 원하는 프로그램을 실행 → 마지막으로 wait()로 종료를 기다리는 구조로 부모-자식 관계 기반의 프로세스 트리를 형성하게 됩니다.

![스크린샷 2025-05-09 133448](https://github.com/user-attachments/assets/d53923ca-3834-4acd-a9d6-62781334c907)

### 4. 리눅스에서의 프로세스와 쓰레드의 차이

(예시답변)
--
프로세스와 스레드는 모두 실행 단위이지만, 메모리 구조와 생성 방식에 큰 차이가 있습니다.

먼저, 프로세스는 fork() 시스템 콜을 통해 생성되며,
부모와 자식이 독립된 메모리 공간을 사용합니다. 이로 인해 격리성이 높지만,
문맥 전환 비용이 크고, 자원 공유가 어렵습니다.

반면, 스레드는 pthread_create() 등의 함수를 통해 생성되고,
하나의 프로세스 내에서 메모리 공간(코드, 데이터, 힙, 파일 디스크립터 등)을 공유합니다.
이로 인해 자원 접근이 빠르고 효율적하지만, 동시에 동기화 문제가 발생할 수 있어 세마포어나 뮤텍스 같은 동기화 기법이 필수입니다.

실제로 저는 Pintos 및 리눅스 커널 모듈 실습에서 스레드와 프로세스의 생성·관리 방식을 직접 구현하거나 확인하며
이 구조적 차이를 코드와 실습으로 체득할 수 있었습니다.

(실습답변)
--
예를 들어, 디바이스 드라이버에서 인터럽트 처리처럼 빠른 응답이 필요한 경우엔
커널 스레드를 등록하거나 tasklet/워크큐를 사용하는 경우가 많고,
반대로 사용자 공간에서 독립된 서비스를 실행해야 할 땐 별도의 프로세스로 관리합니다.

![스크린샷 2025-05-09 133730](https://github.com/user-attachments/assets/c0394496-c433-4999-8320-7d04f063f434)
